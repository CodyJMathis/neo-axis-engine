// Copyright (C) NeoAxis Group Ltd. 8 Copthall, Roseau Valley, 00152 Commonwealth of Dominica.
using Internal.SharpBgfx;
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace NeoAxis
{
	/// <summary>
	/// Screen space reflections effect. It works only with deferred geometry data. May be combined with other reflection techniques.
	/// </summary>
	[DefaultOrderOfEffect( 0 )]
	[Editor.WhenCreatingShowWarningIfItAlreadyExists]
	public class RenderingEffect_Reflection : RenderingEffect
	{
		//it also used by ReflectionProbe
		public static double GlobalMultiplier = 1;
		public static double GlobalMultiplierScreenSpace = 1;

		/// <summary>
		/// The intensity of the effect.
		/// </summary>
		[DefaultValue( 1.0 )]
		[Range( 0, 1 )]
		[Category( "Effect" )]
		public Reference<double> Intensity
		{
			get { if( _intensity.BeginGet() ) Intensity = _intensity.Get( this ); return _intensity.value; }
			set { if( _intensity.BeginSet( this, ref value ) ) { try { IntensityChanged?.Invoke( this ); } finally { _intensity.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="Intensity"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> IntensityChanged;
		ReferenceField<double> _intensity = 1.0;

		//public enum TechniqueEnum
		//{
		//	Auto,
		//	ScreenSpace,
		//}

		///// <summary>
		///// The used technique of the effect. When Auto mode is enabled the reflections are generated by the global illumination (Indirect Lighting component).
		///// </summary>
		//[DefaultValue( TechniqueEnum.Auto )]
		//public Reference<TechniqueEnum> Technique
		//{
		//	get { if( _technique.BeginGet() ) Technique = _technique.Get( this ); return _technique.value; }
		//	set { if( _technique.BeginSet( this, ref value ) ) { try { TechniqueChanged?.Invoke( this ); } finally { _technique.EndSet(); } } }
		//}
		///// <summary>Occurs when the <see cref="Technique"/> property value changes.</summary>
		//public event Action<RenderingEffect_Reflection> TechniqueChanged;
		//ReferenceField<TechniqueEnum> _technique = TechniqueEnum.Auto;

		public enum ResolutionEnum
		{
			Full = 1,
			Half = 2,
			Quarter = 4,
			Eighth = 8,
		}

		/// <summary>
		/// Using lower resolution light buffer can improve performance, but can accentuate aliasing.
		/// </summary>
		[DefaultValue( ResolutionEnum.Half )]
		[Category( "Effect" )]
		public Reference<ResolutionEnum> Resolution
		{
			get { if( _resolution.BeginGet() ) Resolution = _resolution.Get( this ); return _resolution.value; }
			set { if( _resolution.BeginSet( this, ref value ) ) { try { ResolutionChanged?.Invoke( this ); } finally { _resolution.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="Resolution"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> ResolutionChanged;
		ReferenceField<ResolutionEnum> _resolution = ResolutionEnum.Half;

		//no sense because deferred RGBE format is used
		///// <summary>
		///// Whether the high dynamic range is enabled. For Auto mode HDR is disabled on limited devices (mobile).
		///// </summary>
		//[DefaultValue( AutoTrueFalse.Auto )]
		//[Category( "Effect" )]
		//public Reference<AutoTrueFalse> HighDynamicRange
		//{
		//	get { if( _highDynamicRange.BeginGet() ) HighDynamicRange = _highDynamicRange.Get( this ); return _highDynamicRange.value; }
		//	set { if( _highDynamicRange.BeginSet( this, ref value ) ) { try { HighDynamicRangeChanged?.Invoke( this ); } finally { _highDynamicRange.EndSet(); } } }
		//}
		///// <summary>Occurs when the <see cref="HighDynamicRange"/> property value changes.</summary>
		//public event Action<RenderingEffect_Reflection> HighDynamicRangeChanged;
		//ReferenceField<AutoTrueFalse> _highDynamicRange = AutoTrueFalse.Auto;

		public enum ShadowsEnum
		{
			None,
			Simple,
			Full,
		}

		/// <summary>
		/// Whether to calculate shadowing for reflections.
		/// </summary>
		[DefaultValue( ShadowsEnum.Simple )]
		[Category( "Effect" )]
		public Reference<ShadowsEnum> Shadows
		{
			get { if( _shadows.BeginGet() ) Shadows = _shadows.Get( this ); return _shadows.value; }
			set { if( _shadows.BeginSet( this, ref value ) ) { try { ShadowsChanged?.Invoke( this ); } finally { _shadows.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="Shadows"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> ShadowsChanged;
		ReferenceField<ShadowsEnum> _shadows = ShadowsEnum.Simple;

		/// <summary>
		/// The maximum distance from the camera where the effect working.
		/// </summary>
		[DefaultValue( 200.0 )]
		[Range( 10, 1000, RangeAttribute.ConvenientDistributionEnum.Exponential )]
		[Category( "Raymarch" )]
		public Reference<double> MaxDistance
		{
			get { if( _maxDistance.BeginGet() ) MaxDistance = _maxDistance.Get( this ); return _maxDistance.value; }
			set { if( _maxDistance.BeginSet( this, ref value ) ) { try { MaxDistanceChanged?.Invoke( this ); } finally { _maxDistance.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="MaxDistance"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> MaxDistanceChanged;
		ReferenceField<double> _maxDistance = 200.0;

		///// <summary>
		///// The max amount of steps for raymarching.
		///// </summary>
		//[DefaultValue( 50 )]
		//[Range( 1, 200, RangeAttribute.ConvenientDistributionEnum.Exponential )]
		//[Category( "Raymarch" )]
		//public Reference<int> Steps
		//{
		//	get { if( _steps.BeginGet() ) Steps = _steps.Get( this ); return _steps.value; }
		//	set { if( _steps.BeginSet( this, ref value ) ) { try { StepsChanged?.Invoke( this ); } finally { _steps.EndSet(); } } }
		//}
		///// <summary>Occurs when the <see cref="Steps"/> property value changes.</summary>
		//public event Action<RenderingEffect_Reflection> StepsChanged;
		//ReferenceField<int> _steps = 50;

		////public enum QualityEnum
		////{
		////	Low,
		////	Medium,
		////	High,
		////	Highest,
		////}

		/////// <summary>
		/////// The quality of the effect. The amount of calculation steps.
		/////// </summary>
		////[DefaultValue( QualityEnum.High )]//Medium )]
		////[Category( "Raymarch" )]
		////public Reference<QualityEnum> Quality
		////{
		////	get { if( _quality.BeginGet() ) Quality = _quality.Get( this ); return _quality.value; }
		////	set { if( _quality.BeginSet( this, ref value ) ) { try { QualityChanged?.Invoke( this ); } finally { _quality.EndSet(); } } }
		////}
		/////// <summary>Occurs when the <see cref="Quality"/> property value changes.</summary>
		////public event Action<RenderingEffect_Reflection> QualityChanged;
		////ReferenceField<QualityEnum> _quality = QualityEnum.High;// Medium;

		/// <summary>
		/// Initial scale of step size for raymarching.
		/// </summary>
		[DefaultValue( 2.0 )]
		[Range( 0.1, 10, RangeAttribute.ConvenientDistributionEnum.Exponential )]
		[Category( "Raymarch" )]
		public Reference<double> StepScaleStart
		{
			get { if( _stepScaleStart.BeginGet() ) StepScaleStart = _stepScaleStart.Get( this ); return _stepScaleStart.value; }
			set { if( _stepScaleStart.BeginSet( this, ref value ) ) { try { StepScaleStartChanged?.Invoke( this ); } finally { _stepScaleStart.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="StepScaleStart"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> StepScaleStartChanged;
		ReferenceField<double> _stepScaleStart = 2.0;

		/// <summary>
		/// The threshold value to go smaller step for raymarching.
		/// </summary>
		[DefaultValue( 0.5 )]
		[Range( 0, 2, RangeAttribute.ConvenientDistributionEnum.Exponential )]
		[Category( "Raymarch" )]
		public Reference<double> StepScaleThreshold
		{
			get { if( _stepScaleThreshold.BeginGet() ) StepScaleThreshold = _stepScaleThreshold.Get( this ); return _stepScaleThreshold.value; }
			set { if( _stepScaleThreshold.BeginSet( this, ref value ) ) { try { StepScaleThresholdChanged?.Invoke( this ); } finally { _stepScaleThreshold.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="StepScaleThreshold"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> StepScaleThresholdChanged;
		ReferenceField<double> _stepScaleThreshold = 0.5;

		/// <summary>
		/// Average thickness of the world objects for raymarching.
		/// </summary>
		[DefaultValue( 1.0 )]
		[Range( 0, 10, RangeAttribute.ConvenientDistributionEnum.Exponential, 4 )]
		[Category( "Raymarch" )]
		public Reference<double> PenetrationThreshold
		{
			get { if( _penetrationThreshold.BeginGet() ) PenetrationThreshold = _penetrationThreshold.Get( this ); return _penetrationThreshold.value; }
			set { if( _penetrationThreshold.BeginSet( this, ref value ) ) { try { PenetrationThresholdChanged?.Invoke( this ); } finally { _penetrationThreshold.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="PenetrationThreshold"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> PenetrationThresholdChanged;
		ReferenceField<double> _penetrationThreshold = 1.0;

		/// <summary>
		/// Whether to fill invalid pixels with near valid data to fix linear interpolation issues.
		/// </summary>
		[DefaultValue( true )]
		[Category( "Fill Gaps" )]
		public Reference<bool> FillGaps
		{
			get { if( _fillGaps.BeginGet() ) FillGaps = _fillGaps.Get( this ); return _fillGaps.value; }
			set { if( _fillGaps.BeginSet( this, ref value ) ) { try { FillGapsChanged?.Invoke( this ); } finally { _fillGaps.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="FillGaps"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> FillGapsChanged;
		ReferenceField<bool> _fillGaps = true;

		/// <summary>
		/// The radius in pixels to find valid pixels.
		/// </summary>
		[DefaultValue( 7.0 )]//10.0 )]
		[Range( 0, 20 )]
		[Category( "Fill Gaps" )]
		public Reference<double> FillGapsRadius
		{
			get { if( _fillGapsRadius.BeginGet() ) FillGapsRadius = _fillGapsRadius.Get( this ); return _fillGapsRadius.value; }
			set { if( _fillGapsRadius.BeginSet( this, ref value ) ) { try { FillGapsRadiusChanged?.Invoke( this ); } finally { _fillGapsRadius.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="FillGapsRadius"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> FillGapsRadiusChanged;
		ReferenceField<double> _fillGapsRadius = 7.0;//10.0;

		/// <summary>
		/// Whether to do denoising of the reflection texture.
		/// </summary>
		[DefaultValue( true )]
		[Category( "Denoise" )]
		public Reference<bool> Denoise
		{
			get { if( _denoise.BeginGet() ) Denoise = _denoise.Get( this ); return _denoise.value; }
			set { if( _denoise.BeginSet( this, ref value ) ) { try { DenoiseChanged?.Invoke( this ); } finally { _denoise.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="Denoise"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> DenoiseChanged;
		ReferenceField<bool> _denoise = true;

		/// <summary>
		/// Sigma standard deviation of the denoise filter.
		/// </summary>
		[DefaultValue( 5.0 )]
		[Range( 0.0001, 10 )]
		[Category( "Denoise" )]
		public Reference<double> DenoiseSigma
		{
			get { if( _denoiseSigma.BeginGet() ) DenoiseSigma = _denoiseSigma.Get( this ); return _denoiseSigma.value; }
			set { if( _denoiseSigma.BeginSet( this, ref value ) ) { try { DenoiseSigmaChanged?.Invoke( this ); } finally { _denoiseSigma.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="DenoiseSigma"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> DenoiseSigmaChanged;
		ReferenceField<double> _denoiseSigma = 5.0;

		/// <summary>
		/// Sigma coefficient of the denoise filter.
		/// </summary>
		[DefaultValue( 2.0 )]
		[Range( 0, 4 )]
		[Category( "Denoise" )]
		public Reference<double> DenoiseSigmaCoefficient
		{
			get { if( _denoiseSigmaCoefficient.BeginGet() ) DenoiseSigmaCoefficient = _denoiseSigmaCoefficient.Get( this ); return _denoiseSigmaCoefficient.value; }
			set { if( _denoiseSigmaCoefficient.BeginSet( this, ref value ) ) { try { DenoiseSigmaCoefficientChanged?.Invoke( this ); } finally { _denoiseSigmaCoefficient.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="DenoiseSigmaCoefficient"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> DenoiseSigmaCoefficientChanged;
		ReferenceField<double> _denoiseSigmaCoefficient = 2.0;

		/// <summary>
		/// Edge sharpening threshold of the denoise filter.
		/// </summary>
		[DefaultValue( 0.2 )]
		[Range( 0.0001, 1, RangeAttribute.ConvenientDistributionEnum.Exponential )]
		[Category( "Denoise" )]
		public Reference<double> DenoiseEdgeSharpening
		{
			get { if( _denoiseEdgeSharpening.BeginGet() ) DenoiseEdgeSharpening = _denoiseEdgeSharpening.Get( this ); return _denoiseEdgeSharpening.value; }
			set { if( _denoiseEdgeSharpening.BeginSet( this, ref value ) ) { try { DenoiseEdgeSharpeningChanged?.Invoke( this ); } finally { _denoiseEdgeSharpening.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="DenoiseEdgeSharpening"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> DenoiseEdgeSharpeningChanged;
		ReferenceField<double> _denoiseEdgeSharpening = 0.2;

		/// <summary>
		/// The power of blur when roughness is zero.
		/// </summary>
		[DefaultValue( 0.5 )]//1.0 )]
		[Range( 0, 15, RangeAttribute.ConvenientDistributionEnum.Exponential )]
		[Category( "Blur" )]
		public Reference<double> BlurRoughnessMin
		{
			get { if( _blurRoughnessMin.BeginGet() ) BlurRoughnessMin = _blurRoughnessMin.Get( this ); return _blurRoughnessMin.value; }
			set { if( _blurRoughnessMin.BeginSet( this, ref value ) ) { try { BlurRoughnessMinChanged?.Invoke( this ); } finally { _blurRoughnessMin.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="BlurRoughnessMin"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> BlurRoughnessMinChanged;
		ReferenceField<double> _blurRoughnessMin = 0.5;//1.0;

		/// <summary>
		/// Then power of blur when roughness is 0.5.
		/// </summary>
		[DefaultValue( 2.0 )]
		[Range( 0, 15, RangeAttribute.ConvenientDistributionEnum.Exponential )]
		[Category( "Blur" )]
		public Reference<double> BlurRoughnessMiddle
		{
			get { if( _blurRoughnessMiddle.BeginGet() ) BlurRoughnessMiddle = _blurRoughnessMiddle.Get( this ); return _blurRoughnessMiddle.value; }
			set { if( _blurRoughnessMiddle.BeginSet( this, ref value ) ) { try { BlurRoughnessMiddleChanged?.Invoke( this ); } finally { _blurRoughnessMiddle.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="BlurRoughnessMiddle"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> BlurRoughnessMiddleChanged;
		ReferenceField<double> _blurRoughnessMiddle = 2.0;

		/// <summary>
		/// Maximal power of blur.
		/// </summary>
		[DefaultValue( 10.0 )]
		[Range( 0, 15, RangeAttribute.ConvenientDistributionEnum.Exponential )]
		[Category( "Blur" )]
		public Reference<double> BlurRoughnessMax
		{
			get { if( _blurRoughnessMax.BeginGet() ) BlurRoughnessMax = _blurRoughnessMax.Get( this ); return _blurRoughnessMax.value; }
			set { if( _blurRoughnessMax.BeginSet( this, ref value ) ) { try { BlurRoughnessMaxChanged?.Invoke( this ); } finally { _blurRoughnessMax.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="BlurRoughnessMax"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> BlurRoughnessMaxChanged;
		ReferenceField<double> _blurRoughnessMax = 10.0;

		/// <summary>
		/// The blur downscaling mode used.
		/// </summary>
		[DefaultValue( RenderingPipeline_Basic.DownscalingModeEnum.Auto )]
		[Category( "Blur" )]
		public Reference<RenderingPipeline_Basic.DownscalingModeEnum> BlurDownscalingMode
		{
			get { if( _blurDownscalingMode.BeginGet() ) BlurDownscalingMode = _blurDownscalingMode.Get( this ); return _blurDownscalingMode.value; }
			set { if( _blurDownscalingMode.BeginSet( this, ref value ) ) { try { BlurDownscalingModeChanged?.Invoke( this ); } finally { _blurDownscalingMode.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="BlurDownscalingMode"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> BlurDownscalingModeChanged;
		ReferenceField<RenderingPipeline_Basic.DownscalingModeEnum> _blurDownscalingMode = RenderingPipeline_Basic.DownscalingModeEnum.Auto;

		/// <summary>
		/// The level of blur texture downscaling.
		/// </summary>
		[DefaultValue( 0 )]
		[Range( 0, 6 )]
		[Category( "Blur" )]
		public Reference<int> BlurDownscalingValue
		{
			get { if( _blurDownscalingValue.BeginGet() ) BlurDownscalingValue = _blurDownscalingValue.Get( this ); return _blurDownscalingValue.value; }
			set { if( _blurDownscalingValue.BeginSet( this, ref value ) ) { try { BlurDownscalingValueChanged?.Invoke( this ); } finally { _blurDownscalingValue.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="BlurDownscalingValue"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> BlurDownscalingValueChanged;
		ReferenceField<int> _blurDownscalingValue = 0;

		public enum DebugModeEnum
		{
			None,
			OriginalTexture,
			FilledGaps,
			Denoised,
			RoughnessMin,
			RoughnessMiddle,
			RoughnessMax,
		}

		/// <summary>
		/// The debug visualization mode.
		/// </summary>
		[DefaultValue( DebugModeEnum.None )]
		[Category( "Debug" )]
		public Reference<DebugModeEnum> DebugMode
		{
			get { if( _debugMode.BeginGet() ) DebugMode = _debugMode.Get( this ); return _debugMode.value; }
			set { if( _debugMode.BeginSet( this, ref value ) ) { try { DebugModeChanged?.Invoke( this ); } finally { _debugMode.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="DebugMode"/> property value changes.</summary>
		public event Action<RenderingEffect_Reflection> DebugModeChanged;
		ReferenceField<DebugModeEnum> _debugMode = DebugModeEnum.None;


		//[DefaultValue( 8.0 )]
		//[Range( 0, 40 )]
		//public Reference<double> EdgeFactorPower
		//{
		//	get { if( _edgeFactorPower.BeginGet() ) EdgeFactorPower = _edgeFactorPower.Get( this ); return _edgeFactorPower.value; }
		//	set { if( _edgeFactorPower.BeginSet( this, ref value ) ) { try { EdgeFactorPowerChanged?.Invoke( this ); } finally { _edgeFactorPower.EndSet(); } } }
		//}
		///// <summary>Occurs when the <see cref="EdgeFactorPower"/> property value changes.</summary>
		//public event Action<RenderingEffect_Reflection> EdgeFactorPowerChanged;
		//ReferenceField<double> _edgeFactorPower = 8.0;

		//public enum ShadingModelEnum
		//{
		//	Simple,
		//	Default,
		//}

		///// <summary>
		///// The property is intended to optimize shading by means switching to the simple shading model.
		///// </summary>
		//[DefaultValue( ShadingModelEnum.Default )]
		//public Reference<ShadingModelEnum> ShadingModel
		//{
		//	get { if( _shadingModel.BeginGet() ) ShadingModel = _shadingModel.Get( this ); return _shadingModel.value; }
		//	set { if( _shadingModel.BeginSet( this, ref value ) ) { try { ShadingModelChanged?.Invoke( this ); } finally { _shadingModel.EndSet(); } } }
		//}
		///// <summary>Occurs when the <see cref="ShadingModel"/> property value changes.</summary>
		//public event Action<RenderingEffect_Reflection> ShadingModelChanged;
		//ReferenceField<ShadingModelEnum> _shadingModel = ShadingModelEnum.Default;

		/////////////////////////////////////////

		bool IsGIReflectionEnabled()
		{
			var pipeline = FindParent<RenderingPipeline_Basic>();
			if( pipeline != null )
				return pipeline.Reflection;
			return false;
		}

		//bool IsIndirectLightingFullModeEnabled()
		//{
		//	var pipeline = FindParent<RenderingPipeline_Basic>();
		//	if( pipeline != null )
		//	{
		//		var indirectLighting = pipeline.GetComponent<RenderingEffect_IndirectLighting>();
		//		if( indirectLighting != null )
		//		{
		//			if( indirectLighting.Technique.Value == RenderingEffect_IndirectLighting.TechniqueEnum.Full )
		//				return true;
		//		}
		//	}
		//	return false;
		//}

		//bool IsFullMode()
		//{
		//	return Technique.Value == TechniqueEnum.Auto && IsIndirectLightingFullModeEnabled();
		//}

		protected override void OnMetadataGetMembersFilter( Metadata.GetMembersContext context, Metadata.Member member, ref bool skip )
		{
			base.OnMetadataGetMembersFilter( context, member, ref skip );

			var p = member as Metadata.Property;
			if( p != null )
			{
				switch( p.Name )
				{
				case nameof( FillGapsRadius ):
					if( !FillGaps )
						skip = true;
					break;

				case nameof( DenoiseSigma ):
				case nameof( DenoiseSigmaCoefficient ):
				case nameof( DenoiseEdgeSharpening ):
					if( !Denoise )
						skip = true;
					break;

				case nameof( BlurDownscalingValue ):
					if( /*IsGIReflectionEnabled() || */BlurDownscalingMode.Value == RenderingPipeline_Basic.DownscalingModeEnum.Auto )
						skip = true;
					break;

					//case nameof( InitialStepScale ):
					//case nameof( WorldThickness ):
					//case nameof( Resolution ):
					//case nameof( Quality ):
					//case nameof( BlurRoughnessMin ):
					//case nameof( BlurRoughnessMax ):
					//case nameof( BlurDownscalingMode ):
					////case nameof( BlurDownscalingValue ):
					//case nameof( EdgeFactorPower ):
					//	if( IsGIReflectionEnabled() )
					//		skip = true;
					//	break;
				}
			}
		}

		protected override void OnEnabled()
		{
			base.OnEnabled();

			var pipeline = FindParent<RenderingPipeline_Basic>();
			if( pipeline != null )
			{
				pipeline.RenderDeferredShadingGBufferReady += Pipeline_RenderDeferredShadingGBufferReady;
				//pipeline.RenderDeferredShadingEnd += Pipeline_RenderDeferredShadingEnd;
				////pipeline.RenderBegin += Pipeline_RenderBegin;
			}
		}

		protected override void OnDisabled()
		{
			var pipeline = FindParent<RenderingPipeline_Basic>();
			if( pipeline != null )
			{
				pipeline.RenderDeferredShadingGBufferReady -= Pipeline_RenderDeferredShadingGBufferReady;
				//pipeline.RenderDeferredShadingEnd -= Pipeline_RenderDeferredShadingEnd;
				////pipeline.RenderBegin -= Pipeline_RenderBegin;
			}

			base.OnDisabled();
		}

		private void Pipeline_RenderDeferredShadingGBufferReady( RenderingPipeline_Basic sender, ViewportRenderingContext context, RenderingPipeline_Basic.FrameData frameData, ref ImageComponent sceneTexture )//, ref bool skipLighting )
		{
			var multiplier = GlobalMultiplierScreenSpace * Intensity;
			if( !( EnabledInHierarchy && sender.GetUseMultiRenderTargets() && multiplier > 0 && !IsGIReflectionEnabled() ) )
				return;

			var pipeline = context.RenderingPipeline;

			float aspectRatio = (float)context.Owner.CameraSettings.AspectRatio;
			float fov = (float)context.Owner.CameraSettings.FieldOfView;

			var reflectionTextureSize = ( context.SizeInPixelsLowResolutionBeforeUpscale.ToVector2() * multiplier / (int)Resolution.Value ).ToVector2I();
			if( reflectionTextureSize.X == 0 || reflectionTextureSize.Y == 0 )
				return;
			if( reflectionTextureSize.X > RenderingSystem.Capabilities.MaxTextureSize )
				reflectionTextureSize.X = RenderingSystem.Capabilities.MaxTextureSize;
			if( reflectionTextureSize.Y > RenderingSystem.Capabilities.MaxTextureSize )
				reflectionTextureSize.Y = RenderingSystem.Capabilities.MaxTextureSize;

			//var reflectionTextureSize = ( context.SizeInPixelsLowResolutionBeforeUpscale.ToVector2() * Math.Max( GlobalMultiplier, 1 ) / (int)Resolution.Value ).ToVector2I();

			var reflectionTexture = context.RenderTarget2D_Alloc( reflectionTextureSize, sceneTexture.Result.ResultFormat );
			{
				context.SetViewport( reflectionTexture.Result.GetRenderTarget().Viewports[ 0 ] );

				var shader = new CanvasRenderer.ShaderItem();
				shader.VertexProgramFileName = @"Base\Shaders\EffectsCommon_vs.sc";
				shader.FragmentProgramFileName = @"Base\Shaders\Effects\ScreenSpaceReflection\SSR_fs.sc";

				//int maxSteps = 50;
				//switch( Quality.Value )
				//{
				//case QualityEnum.Low: maxSteps = 20; break;
				//case QualityEnum.Medium: maxSteps = 40; break;
				//case QualityEnum.High: maxSteps = 70; break;
				//case QualityEnum.Highest: maxSteps = 110; break;
				//}
				//shader.Defines.Add( new CanvasRenderer.ShaderItem.DefineItem( "MAX_STEPS", maxSteps.ToString() ) );

				var shadows = false;
				if( Shadows.Value != ShadowsEnum.None )
				{
					foreach( var lightIndex in frameData.LightsInFrustumSorted )
					{
						var lightItem = frameData.Lights[ lightIndex ];
						if( lightItem.prepareShadows )
						{
							shadows = true;
							break;
						}
					}
				}
				if( shadows )
				{
					shader.Defines.Add( new CanvasRenderer.ShaderItem.DefineItem( "SHADOW_MAP" ) );
					if( Shadows.Value == ShadowsEnum.Simple )
						shader.Defines.Add( new CanvasRenderer.ShaderItem.DefineItem( "SHADOW_MAP_FORCE_SIMPLE" ) );
				}

				//if( ShadingModel.Value == ShadingModelEnum.Simple )
				//	shader.Defines.Add( new CanvasRenderer.ShaderItem.DefineItem( "SHADING_MODEL_FORCE_SIMPLE" ) );

				context.ObjectsDuringUpdate.namedTextures.TryGetValue( "gBuffer0Texture", out var gBuffer0Texture );
				context.ObjectsDuringUpdate.namedTextures.TryGetValue( "normalTexture", out var normalTexture );
				context.ObjectsDuringUpdate.namedTextures.TryGetValue( "gBuffer2Texture", out var gBuffer2Texture );
				context.ObjectsDuringUpdate.namedTextures.TryGetValue( "gBuffer3Texture", out var gBuffer3Texture );
				context.ObjectsDuringUpdate.namedTextures.TryGetValue( "gBuffer4Texture", out var gBuffer4Texture );
				context.ObjectsDuringUpdate.namedTextures.TryGetValue( "gBuffer5Texture", out var gBuffer5Texture );
				context.ObjectsDuringUpdate.namedTextures.TryGetValue( "depthTexture", out var depthTexture );

				pipeline.GetBackgroundEnvironmentData( context, frameData, out var ambientLightTexture, out var ambientLightIrradiance );

				var u_deferredEnvironmentData = GpuProgramManager.RegisterUniform( "u_deferredEnvironmentData", UniformType.Vector4, 4 );
				var u_deferredEnvironmentIrradiance = GpuProgramManager.RegisterUniform( "u_deferredEnvironmentIrradiance", UniformType.Vector4, 9 );

				unsafe
				{
					var data = new RenderingPipeline_Basic.DeferredEnvironmentDataUniform();
					data.rotation = ambientLightTexture.Rotation;
					data.multiplierAndAffect = ambientLightTexture.MultiplierAndAffect;
					data.iblRotation = ambientLightIrradiance.Rotation;
					data.iblMultiplierAndAffect = ambientLightIrradiance.MultiplierAndAffect;
					Bgfx.SetUniform( u_deferredEnvironmentData, &data, 4 );

					fixed( Vector4F* harmonics2 = ambientLightIrradiance.Harmonics ?? RenderingPipeline.EnvironmentIrradianceData.GrayHarmonics )
						Bgfx.SetUniform( u_deferredEnvironmentIrradiance, harmonics2, 9 );
				}

				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, depthTexture, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 1, gBuffer0Texture, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 2, normalTexture, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 3, gBuffer2Texture, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 16/*4*/, gBuffer3Texture, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 17/*5*/, gBuffer4Texture, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 6, gBuffer5Texture, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 4, ambientLightTexture.Texture, TextureAddressingMode.Clamp, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );

				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 7, RenderingPipeline_Basic.BrdfLUT, TextureAddressingMode.Clamp, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );

				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 8/*s_lightsTexture*/, frameData.LightsTexture, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.Point ) );

				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 9/*s_lightGrid*/, frameData.LightGrid ?? ResourceUtility.DummyTexture3DFloat32RGBA, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.Point ) );

				//shadows
				{
					var isByte4Format = RenderingSystem.ShadowTextureFormat == ProjectSettingsPage_Rendering.ShadowTextureFormatEnum.Byte4;
					var filtering = isByte4Format ? FilterOption.Point : FilterOption.Linear;
					var textureFlags = isByte4Format ? 0 : TextureFlags.CompareLessEqual;

					//shadow map directional
					{
						var shadowMap = frameData.ShadowTextureArrayDirectional;
						if( shadowMap == null )
							shadowMap = isByte4Format ? ResourceUtility.DummyTexture2DArrayARGB8 : ResourceUtility.DummyShadowMap2DArrayFloat32R;

						var wrap = isByte4Format;

						var textureValue = new ViewportRenderingContext.BindTextureData( 10/*s_shadowMapShadowDirectional*/, shadowMap, wrap ? TextureAddressingMode.Wrap : TextureAddressingMode.Clamp, filtering, filtering, FilterOption.None, textureFlags );
						shader.Parameters.Set( ref textureValue );
					}

					//shadow map array spot
					{
						var shadowMap = frameData.ShadowTextureArraySpot;
						if( shadowMap == null )
							shadowMap = isByte4Format ? ResourceUtility.DummyTexture2DArrayARGB8 : ResourceUtility.DummyShadowMap2DArrayFloat32R;

						var textureValue = new ViewportRenderingContext.BindTextureData( 11/*s_shadowMapShadowSpot*/, shadowMap, TextureAddressingMode.Clamp, filtering, filtering, FilterOption.None, textureFlags );
						shader.Parameters.Set( ref textureValue );
					}

					//shadow map array point
					{
						var shadowMap = frameData.ShadowTextureArrayPoint;
						if( shadowMap == null )
							shadowMap = isByte4Format ? ResourceUtility.DummyTextureCubeArrayARGB8/*WhiteTextureCube*/ : ResourceUtility.DummyShadowMapCubeArrayFloat32R;

						var textureValue = new ViewportRenderingContext.BindTextureData( 12/*s_shadowMapShadowPoint*/, shadowMap, TextureAddressingMode.Clamp, filtering, filtering, FilterOption.None, textureFlags );
						shader.Parameters.Set( ref textureValue );
					}
				}

				//light masks
				if( RenderingSystem.LightMask )
				{
					//mask array directional
					{
						var texture = frameData.MaskTextureArrayDirectional ?? ResourceUtility.WhiteTexture2D;
						shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 13/*s_lightMaskDirectional*/, texture, TextureAddressingMode.Wrap, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );
					}

					//mask array spot
					{
						var texture = frameData.MaskTextureArraySpot ?? ResourceUtility.WhiteTexture2D;
						shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 14/*s_lightMaskSpot*/, texture, TextureAddressingMode.Clamp, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );
					}

					//mask array point
					{
						var texture = frameData.MaskTextureArrayPoint ?? ResourceUtility.WhiteTextureCube;
						shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 15/*s_lightMaskPoint*/, texture, TextureAddressingMode.Wrap, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );
					}
				}

				var parameters = new Vector4F[ 3 ];
				parameters[ 0 ] = new Vector4F( sceneTexture.Result.ResultSize.X, sceneTexture.Result.ResultSize.Y, 1.0f / sceneTexture.Result.ResultSize.X, 1.0f / sceneTexture.Result.ResultSize.Y );
				parameters[ 1 ] = new Vector4F( (float)StepScaleStart.Value, (float)PenetrationThreshold.Value, fov, aspectRatio );
				parameters[ 2 ] = new Vector4F( (float)StepScaleThreshold.Value, (float)MaxDistance, 0, 0 );

				shader.Parameters.Set( "u_ssrParameters", parameters, ParameterType.Vector4, parameters.Length );

				//shader.Parameters.Set( "edgeFactorPower", (float)EdgeFactorPower );
				////shader.Parameters.Set( "ambientLightTextureRotation", environmentTexture.Rotation.ToVector4() );
				////shader.Parameters.Set( "ambientLightTextureMultiplierAndAffect", environmentTexture.MultiplierAndAffect );

				context.RenderQuadToCurrentViewport( shader );
			}

			var debugMode = DebugMode.Value;

			if( debugMode == DebugModeEnum.OriginalTexture )
			{
				var texture = context.RenderTarget2D_Alloc( reflectionTexture.Result.ResultSize, reflectionTexture.Result.ResultFormat );
				context.SetViewport( texture.Result.GetRenderTarget().Viewports[ 0 ] );
				pipeline.CopyToCurrentViewport( context, reflectionTexture );

				context.ObjectsDuringUpdate.namedTextures[ "ssrDebug" ] = texture;
			}

			//fill gaps
			if( FillGaps )
			{
				//!!!!use compute but image must have compute write flag. need prepare reflection texture on compute

				var reflectionTexture2 = context.RenderTarget2D_Alloc( reflectionTexture.Result.ResultSize, reflectionTexture.Result.ResultFormat );
				{
					context.SetViewport( reflectionTexture2.Result.GetRenderTarget().Viewports[ 0 ] );

					var shader = new CanvasRenderer.ShaderItem();
					shader.VertexProgramFileName = @"Base\Shaders\EffectsCommon_vs.sc";
					shader.FragmentProgramFileName = @"Base\Shaders\Effects\ScreenSpaceReflection\FillGaps_fs.sc";

					shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, reflectionTexture, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

					var pixelSize = Vector2.One / reflectionTexture.Result.ResultSize.ToVector2();
					var scale = pixelSize * FillGapsRadius;
					shader.Parameters.Set( "u_ssrFillGapsParameters", new Vector4F( (float)scale.X, (float)scale.Y, 0, 0 ) );

					context.RenderQuadToCurrentViewport( shader );
				}

				context.DynamicTexture_Free( reflectionTexture );
				reflectionTexture = reflectionTexture2;
			}

			if( debugMode == DebugModeEnum.FilledGaps )
			{
				var texture = context.RenderTarget2D_Alloc( reflectionTexture.Result.ResultSize, reflectionTexture.Result.ResultFormat );
				context.SetViewport( texture.Result.GetRenderTarget().Viewports[ 0 ] );
				pipeline.CopyToCurrentViewport( context, reflectionTexture );

				context.ObjectsDuringUpdate.namedTextures[ "ssrDebug" ] = texture;
			}

			//var depthCheck = false;
			//var alphaAsWeight = false;
			//var test = EngineApp._DebugCapsLock;

			//denoise
			if( Denoise )
			{
				var reflectionTexture2 = pipeline.Denoise( context, reflectionTexture, DenoiseSigma, DenoiseSigmaCoefficient, DenoiseEdgeSharpening );

				context.DynamicTexture_Free( reflectionTexture );
				reflectionTexture = reflectionTexture2;
			}

			if( debugMode == DebugModeEnum.Denoised )
			{
				var texture = context.RenderTarget2D_Alloc( reflectionTexture.Result.ResultSize, reflectionTexture.Result.ResultFormat );
				context.SetViewport( texture.Result.GetRenderTarget().Viewports[ 0 ] );
				pipeline.CopyToCurrentViewport( context, reflectionTexture );

				context.ObjectsDuringUpdate.namedTextures[ "ssrDebug" ] = texture;
			}

			var ssrArray = context.RenderTarget2D_Alloc( reflectionTexture.Result.ResultSize, reflectionTexture.Result.ResultFormat, arrayLayers: 3 );

			//min
			ImageComponent blurRoughnessMin;
			if( BlurRoughnessMin > 0 )
			{
				var settings = new RenderingPipeline_Basic.GaussianBlurSettings();
				settings.SourceTexture = reflectionTexture;
				settings.BlurFactor = BlurRoughnessMin;
				settings.DownscalingMode = BlurDownscalingMode;
				settings.DownscalingValue = BlurDownscalingValue;
				//settings.DepthCheck = depthCheck;
				//settings.AlphaAsWeight = alphaAsWeight;
				//settings.Test = test;
				blurRoughnessMin = pipeline.GaussianBlur( context, settings );

				context.DynamicTexture_Free( reflectionTexture );
			}
			else
				blurRoughnessMin = reflectionTexture;

			//copy min to ssrArray
			context.SetViewport( ssrArray.Result.GetRenderTarget( slice: 0 ).Viewports[ 0 ] );
			pipeline.CopyToCurrentViewport( context, blurRoughnessMin );

			//middle
			ImageComponent blurRoughnessMiddle;
			{
				var settings = new RenderingPipeline_Basic.GaussianBlurSettings();
				settings.SourceTexture = blurRoughnessMin;
				settings.BlurFactor = BlurRoughnessMiddle;
				settings.DownscalingMode = BlurDownscalingMode;
				settings.DownscalingValue = BlurDownscalingValue;
				//settings.DepthCheck = depthCheck;
				//settings.AlphaAsWeight = alphaAsWeight;
				//settings.Test = test;
				blurRoughnessMiddle = pipeline.GaussianBlur( context, settings );
			}

			//copy middle to ssrArray
			context.SetViewport( ssrArray.Result.GetRenderTarget( slice: 1 ).Viewports[ 0 ] );
			pipeline.CopyToCurrentViewport( context, blurRoughnessMiddle );

			//free min
			context.DynamicTexture_Free( blurRoughnessMin );

			//max
			ImageComponent blurRoughnessMax;
			{
				var settings = new RenderingPipeline_Basic.GaussianBlurSettings();
				settings.SourceTexture = blurRoughnessMiddle;
				settings.BlurFactor = BlurRoughnessMax;
				settings.DownscalingMode = BlurDownscalingMode;
				settings.DownscalingValue = BlurDownscalingValue;
				//settings.DepthCheck = depthCheck;
				//settings.AlphaAsWeight = alphaAsWeight;
				//settings.Test = test;
				blurRoughnessMax = pipeline.GaussianBlur( context, settings );
			}

			//copy max to ssrArray
			context.SetViewport( ssrArray.Result.GetRenderTarget( slice: 2 ).Viewports[ 0 ] );
			pipeline.CopyToCurrentViewport( context, blurRoughnessMax );

			//free middle, max
			context.DynamicTexture_Free( blurRoughnessMiddle );
			context.DynamicTexture_Free( blurRoughnessMax );



			////min
			//if( BlurRoughnessMin > 0 )
			//{
			//	ImageComponent blurRoughnessMin;
			//	{
			//		var settings = new RenderingPipeline_Basic.GaussianBlurSettings();
			//		settings.SourceTexture = reflectionTexture;
			//		settings.BlurFactor = BlurRoughnessMin;
			//		settings.DownscalingMode = BlurDownscalingMode;
			//		settings.DownscalingValue = BlurDownscalingValue;
			//		//settings.DepthCheck = depthCheck;
			//		//settings.AlphaAsWeight = alphaAsWeight;
			//		//settings.Test = test;
			//		blurRoughnessMin = pipeline.GaussianBlur( context, settings );
			//	}

			//	if( debugMode != DebugModeEnum.ReflectionTexture )
			//		context.DynamicTexture_Free( reflectionTexture );

			//	context.SetViewport( ssrArray.Result.GetRenderTarget( slice: 0 ).Viewports[ 0 ] );
			//	pipeline.CopyToCurrentViewport( context, blurRoughnessMin, filtering: FilterOption.Linear );

			//	context.DynamicTexture_Free( blurRoughnessMin );
			//}
			//else
			//{
			//	//!!!!без копирования

			//	context.SetViewport( ssrArray.Result.GetRenderTarget( slice: 0 ).Viewports[ 0 ] );
			//	pipeline.CopyToCurrentViewport( context, reflectionTexture );

			//	if( debugMode != DebugModeEnum.ReflectionTexture )
			//		context.DynamicTexture_Free( reflectionTexture );
			//}

			////middle
			//{
			//	ImageComponent blurRoughnessMiddle;
			//	{
			//		var settings = new RenderingPipeline_Basic.GaussianBlurSettings();
			//		settings.SourceTexture = ssrArray;
			//		settings.SourceTextureIsArray = true;
			//		settings.SourceTextureArrayIndex = 0;
			//		settings.BlurFactor = BlurRoughnessMiddle;
			//		settings.DownscalingMode = BlurDownscalingMode;
			//		settings.DownscalingValue = BlurDownscalingValue;
			//		//settings.DepthCheck = depthCheck;
			//		//settings.AlphaAsWeight = alphaAsWeight;
			//		//settings.Test = test;
			//		blurRoughnessMiddle = pipeline.GaussianBlur( context, settings );
			//	}

			//	context.SetViewport( ssrArray.Result.GetRenderTarget( slice: 1 ).Viewports[ 0 ] );
			//	pipeline.CopyToCurrentViewport( context, blurRoughnessMiddle );

			//	context.DynamicTexture_Free( blurRoughnessMiddle );
			//}

			////max
			//{
			//	ImageComponent blurRoughnessMax;
			//	{
			//		var settings = new RenderingPipeline_Basic.GaussianBlurSettings();
			//		settings.SourceTexture = ssrArray;
			//		settings.SourceTextureIsArray = true;
			//		settings.SourceTextureArrayIndex = 1;
			//		settings.BlurFactor = BlurRoughnessMax;
			//		settings.DownscalingMode = BlurDownscalingMode;
			//		settings.DownscalingValue = BlurDownscalingValue;
			//		//settings.DepthCheck = depthCheck;
			//		//settings.AlphaAsWeight = alphaAsWeight;
			//		//settings.Test = test;
			//		blurRoughnessMax = pipeline.GaussianBlur( context, settings );
			//	}

			//	context.SetViewport( ssrArray.Result.GetRenderTarget( slice: 2 ).Viewports[ 0 ] );
			//	pipeline.CopyToCurrentViewport( context, blurRoughnessMax );

			//	context.DynamicTexture_Free( blurRoughnessMax );
			//}




			//var min = Math.Min( BlurRoughnessMin, BlurRoughnessMax );
			//var max = Math.Max( BlurRoughnessMin, BlurRoughnessMax );

			////!!!!
			//min = 0;
			//max = 0;
			////if( EngineApp._DebugCapsLock )
			////{
			////	min = 0;
			////	max = 0;
			////}

			////ImageComponent blurRoughnessMin;
			////{
			////	var settings = new RenderingPipeline_Basic.GaussianBlurSettings();
			////	settings.SourceTexture = reflectionTexture;
			////	settings.BlurFactor = min;
			////	settings.DownscalingMode = BlurDownscalingMode;
			////	settings.DownscalingValue = BlurDownscalingValue;
			////	//settings.DepthCheck = depthCheck;
			////	//settings.AlphaAsWeight = alphaAsWeight;
			////	//settings.Test = test;
			////	blurRoughnessMin = pipeline.GaussianBlur( context, settings );
			////}

			////!!!!можно одну из другой получать


			//ImageComponent blurRoughnessMax;
			//{
			//	var settings = new RenderingPipeline_Basic.GaussianBlurSettings();
			//	settings.SourceTexture = reflectionTexture;
			//	settings.BlurFactor = max;
			//	settings.DownscalingMode = BlurDownscalingMode;
			//	settings.DownscalingValue = BlurDownscalingValue;
			//	//settings.DepthCheck = depthCheck;
			//	//settings.AlphaAsWeight = alphaAsWeight;
			//	//settings.Test = test;
			//	blurRoughnessMax = pipeline.GaussianBlur( context, settings );
			//}

			////var blurRoughnessMin = pipeline.GaussianBlur( context, reflectionTexture, min, BlurDownscalingMode, BlurDownscalingValue, depthCheck );
			////var blurRoughnessMax = pipeline.GaussianBlur( context, reflectionTexture, max, BlurDownscalingMode, BlurDownscalingValue, depthCheck );


			//add to named textures
			context.ObjectsDuringUpdate.namedTextures[ "ssr" ] = ssrArray;

			//context.ObjectsDuringUpdate.namedTextures[ "ssr_min" ] = blurRoughnessMin;
			//context.ObjectsDuringUpdate.namedTextures[ "ssr_max" ] = blurRoughnessMax;


			////debug pass
			//if( debugMode != DebugModeEnum.None )
			//{
			//	var finalTexture = context.RenderTarget2D_Alloc( sceneTexture.Result.ResultSize, sceneTexture.Result.ResultFormat );
			//	{
			//		context.SetViewport( finalTexture.Result.GetRenderTarget().Viewports[ 0 ] );

			//		var shader = new CanvasRenderer.ShaderItem();
			//		shader.VertexProgramFileName = @"Base\Shaders\EffectsCommon_vs.sc";
			//		shader.FragmentProgramFileName = @"Base\Shaders\Effects\ScreenSpaceReflection\SSR_Debug_fs.sc";

			//		shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, reflectionTexture, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );
			//		shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 1, ssrArray, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

			//		var index = -1;
			//		switch( debugMode )
			//		{
			//		case DebugModeEnum.RoughnessMin: index = 0; break;
			//		case DebugModeEnum.RoughnessMiddle: index = 1; break;
			//		case DebugModeEnum.RoughnessMax: index = 3; break;
			//		}
			//		shader.Parameters.Set( "u_ssrDebugParameters", new Vector4F( index, 0, 0, 0 ) );


			//		//switch( debugMode )
			//		//{
			//		//case DebugModeEnum.ReflectionTexture:
			//		//	shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, reflectionTexture, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );
			//		//	break;

			//		//case DebugModeEnum.RoughnessMin:
			//		//	shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, blurRoughnessMin, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );
			//		//	break;

			//		//case DebugModeEnum.RoughnessMax:
			//		//	shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, blurRoughnessMax, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );
			//		//	break;
			//		//}

			//		context.RenderQuadToCurrentViewport( shader );
			//	}

			//	//replace scene texture
			//	sceneTexture = finalTexture;
			//	skipLighting = true;
			//}


			////free targets
			//context.DynamicTexture_Free( reflectionTexture );

			//context.DynamicTexture_Free( blurRoughnessMin );
			//context.DynamicTexture_Free( blurRoughnessMax );
			//context.DynamicTexture_Free( actualTexture );
			////update result
			//sceneTexture = finalTexture;
		}

		public override ScreenLabelInfo GetScreenLabelInfo()
		{
			return new ScreenLabelInfo( "ScreenEffect", true );
		}

		protected override void OnRender( ViewportRenderingContext context, RenderingPipeline_Basic.FrameData frameData, ref ImageComponent actualTexture )
		{
			base.OnRender( context, frameData, ref actualTexture );

			//debug visualization
			var debugMode = DebugMode.Value;
			if( debugMode != DebugModeEnum.None && context.ObjectsDuringUpdate.namedTextures.TryGetValue( "ssr", out var ssrArray ) )
			{
				context.ObjectsDuringUpdate.namedTextures.TryGetValue( "ssrDebug", out var ssrDebug );

				//prepare texture
				var finalTexture = context.RenderTarget2D_Alloc( actualTexture.Result.ResultSize, actualTexture.Result.ResultFormat );
				{
					context.SetViewport( finalTexture.Result.GetRenderTarget().Viewports[ 0 ] );

					var shader = new CanvasRenderer.ShaderItem();
					shader.VertexProgramFileName = @"Base\Shaders\EffectsCommon_vs.sc";
					shader.FragmentProgramFileName = @"Base\Shaders\Effects\ScreenSpaceReflection\SSR_Debug_fs.sc";

					shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, ssrDebug ?? ResourceUtility.WhiteTexture2D, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

					shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 1, ssrArray, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

					var index = -1;
					switch( debugMode )
					{
					case DebugModeEnum.RoughnessMin: index = 0; break;
					case DebugModeEnum.RoughnessMiddle: index = 1; break;
					case DebugModeEnum.RoughnessMax: index = 2; break;
					}
					var showOriginal = debugMode == DebugModeEnum.OriginalTexture || debugMode == DebugModeEnum.FilledGaps;
					shader.Parameters.Set( "u_ssrDebugParameters", new Vector4F( index, showOriginal ? 1 : 0, 0, 0 ) );

					context.RenderQuadToCurrentViewport( shader );
				}

				//replace actual texture
				context.DynamicTexture_Free( actualTexture );
				actualTexture = finalTexture;
			}
		}
	}
}






//else
//{

////final pass
//finalTexture = context.RenderTarget2D_Alloc( actualTexture.Result.ResultSize, actualTexture.Result.ResultFormat );
//{
//	context.SetViewport( finalTexture.Result.GetRenderTarget().Viewports[ 0 ] );

//	if( debugMode != DebugModeEnum.None )
//	{
//	}
//	else
//	{


//		//!!!!
//		var ambientLight = frameData.Lights[ frameData.LightsInFrustumSorted[ 0 ] ];
//		var ambientLightPower = ambientLight.data.Power;

//		//!!!!reflection probes?
//		pipeline.GetBackgroundEnvironmentData( context, frameData, /*true, */out var environmentTexture, out var environmentTextureIBL );



//		var shader = new CanvasRenderer.ShaderItem();
//		shader.VertexProgramFileName = @"Base\Shaders\EffectsCommon_vs.sc";
//		shader.FragmentProgramFileName = @"Base\Shaders\Effects\ScreenSpaceReflection\SSR_Apply_fs.sc";

//		context.ObjectsDuringUpdate.namedTextures.TryGetValue( "gBuffer0Texture", out var gBuffer0Texture );
//		context.ObjectsDuringUpdate.namedTextures.TryGetValue( "depthTexture", out var depthTexture );
//		context.ObjectsDuringUpdate.namedTextures.TryGetValue( "normalTexture", out var normalTexture );
//		context.ObjectsDuringUpdate.namedTextures.TryGetValue( "gBuffer2Texture", out var gBuffer2Texture );

//		shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, actualTexture,
//			TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//		//!!!!почему Point. что еще Linear сделать

//		shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 1, blurRoughnessMin,
//			TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//		shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 2, blurRoughnessMax,
//			TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//		//shader.Parameters.Set( "1", new GpuMaterialPass.TextureParameterValue( reflectionTexture,
//		//	TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//		//shader.Parameters.Set( "2", new GpuMaterialPass.TextureParameterValue( bluredReflection,
//		//	TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//		shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 3, depthTexture,
//			TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//		shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 4, normalTexture,
//			TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//		shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 5, environmentTexture.Texture,
//			TextureAddressingMode.Clamp, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );

//		//shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 6, environmentTextureIBL.Value.texture,
//		//	TextureAddressingMode.Clamp, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );

//		shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 7, RenderingPipeline_Basic.BrdfLUT,
//			TextureAddressingMode.Clamp, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );

//		shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 8, gBuffer2Texture,
//			TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.Point ) );

//		shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 9, gBuffer0Texture,
//			TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.Point ) );

//		//shader.Parameters.Set( "invViewProj", invViewProjMatrix );
//		shader.Parameters.Set( "intensity", (float)MathEx.Saturate( multiplier ) );// Intensity );

//		//!!!!prefixes

//		//!!!!почему юзается ambient light

//		shader.Parameters.Set( "ambientLightPower", ambientLightPower );
//		shader.Parameters.Set( "ambientLightTextureRotation", environmentTexture.Rotation.ToVector4() );
//		shader.Parameters.Set( "ambientLightTextureMultiplierAndAffect", environmentTexture.MultiplierAndAffect );

//		//var parameters = new Vector4F(  );
//		//shader.Parameters.Set( "u_reflectionParameters", parameters );

//		context.RenderQuadToCurrentViewport( shader );
//	}
//}

//}

//context.DynamicTexture_Free( blurRoughnessMin );
//context.DynamicTexture_Free( blurRoughnessMax );

////context.RenderTarget_Free( bluredReflection );

//context.DynamicTexture_Free( actualTexture );

////update result
//sceneTexture = finalTexture;



//private void Pipeline_RenderDeferredShadingEnd( RenderingPipeline_Basic sender, ViewportRenderingContext context, RenderingPipeline_Basic.FrameData frameData, ref ImageComponent sceneTexture )
//{
//	var multiplier = GlobalMultiplier * Intensity;

//	if( EnabledInHierarchy && sender.GetUseMultiRenderTargets() && multiplier > 0 && !IsGIReflectionEnabled() )
//	{
//		var actualTexture = sceneTexture;

//		var pipeline = context.RenderingPipeline;

//		float aspectRatio = (float)context.Owner.CameraSettings.AspectRatio;
//		float fov = (float)context.Owner.CameraSettings.FieldOfView;


//		//!!!!
//		var reflectionTextureSize = ( context.SizeInPixelsLowResolutionBeforeUpscale.ToVector2() * Math.Max( multiplier, 1 ) / (int)Resolution.Value ).ToVector2I();
//		//if(reflectionTextureSize.X > RenderingSystem.ma
//		//var reflectionTextureSize = ( context.SizeInPixelsLowResolutionBeforeUpscale.ToVector2() * Math.Max( GlobalMultiplier, 1 ) / (int)Resolution.Value ).ToVector2I();

//		var reflectionTexture = context.RenderTarget2D_Alloc( reflectionTextureSize, actualTexture.Result.ResultFormat );
//		if( reflectionTexture == null )
//			return;

//		{
//			context.SetViewport( reflectionTexture.Result.GetRenderTarget().Viewports[ 0 ] );

//			var shader = new CanvasRenderer.ShaderItem();
//			shader.VertexProgramFileName = @"Base\Shaders\EffectsCommon_vs.sc";
//			shader.FragmentProgramFileName = @"Base\Shaders\Effects\ScreenSpaceReflection\SSR_fs.sc";

//			int maxSteps = 50;
//			switch( Quality.Value )
//			{
//			case QualityEnum.Lowest: maxSteps = 15; break;
//			case QualityEnum.Low: maxSteps = 25; break;
//			case QualityEnum.Medium: maxSteps = 40; break;
//			case QualityEnum.High: maxSteps = 60; break;
//			case QualityEnum.Highest: maxSteps = 100; break;
//			}

//			shader.Defines.Add( new CanvasRenderer.ShaderItem.DefineItem( "MAX_STEPS", maxSteps.ToString() ) );

//			context.ObjectsDuringUpdate.namedTextures.TryGetValue( "gBuffer0Texture", out var gBuffer0Texture );
//			context.ObjectsDuringUpdate.namedTextures.TryGetValue( "depthTexture", out var depthTexture );
//			context.ObjectsDuringUpdate.namedTextures.TryGetValue( "normalTexture", out var normalTexture );
//			context.ObjectsDuringUpdate.namedTextures.TryGetValue( "gBuffer2Texture", out var gBuffer2Texture );

//			shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, depthTexture,
//				TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//			shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 1, actualTexture,
//				TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//			shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 2, normalTexture,
//			   TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//			//shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 3, environmentTexture.Texture,
//			//	TextureAddressingMode.Clamp, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );

//			////shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 4, environmentTextureIBL.Value.texture,
//			////	TextureAddressingMode.Clamp, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );

//			shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 5, RenderingPipeline_Basic.BrdfLUT,
//				TextureAddressingMode.Clamp, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );

//			shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 6, gBuffer2Texture,
//				TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.Point ) );

//			shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 7, gBuffer0Texture,
//				TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.Point ) );

//			//!!!часть параметров брать из UniformsGeneral.sh?

//			//!!!!prefixes

//			//shader.Parameters.Set( "viewProj", viewProjMatrix );
//			//shader.Parameters.Set( "invViewProj", invViewProjMatrix );
//			//shader.Parameters.Set( "cameraPosition", cameraPosition );
//			shader.Parameters.Set( "edgeFactorPower", (float)EdgeFactorPower );
//			shader.Parameters.Set( "initialStepScale", (float)InitialStepScale.Value );
//			shader.Parameters.Set( "worldThickness", (float)WorldThickness.Value );

//			shader.Parameters.Set( "colorTextureSize", new Vector4F( actualTexture.Result.ResultSize.X, actualTexture.Result.ResultSize.Y, 0, 0 ) );
//			shader.Parameters.Set( "fov", fov );
//			shader.Parameters.Set( "aspectRatio", aspectRatio );

//			//shader.Parameters.Set( "ambientLightTextureRotation", environmentTexture.Rotation.ToVector4() );
//			//shader.Parameters.Set( "ambientLightTextureMultiplierAndAffect", environmentTexture.MultiplierAndAffect );

//			context.RenderQuadToCurrentViewport( shader );
//		}

//		//!!!!depth check

//		//!!!!disable downscale by default?

//		//!!!!неверно блюрит. чернота размазывается. учитывать альфу

//		//!!!!свойством?
//		var depthCheck = true;// EngineApp._DebugCapsLock;

//		var min = BlurRoughnessMin.Value;
//		var max = BlurRoughnessMax.Value;
//		if( min > max )
//			min = max;
//		var blurRoughnessMin = pipeline.GaussianBlur( context, reflectionTexture, min, BlurDownscalingMode, BlurDownscalingValue, depthCheck );
//		var blurRoughnessMax = pipeline.GaussianBlur( context, reflectionTexture, max, BlurDownscalingMode, BlurDownscalingValue, depthCheck );
//		//// Blur Pass:
//		//var bluredReflection = pipeline.GaussianBlur( context, this, reflectionTexture, BlurFactorOnMaxRoughness, BlurDownscalingMode, BlurDownscalingValue );


//		//final pass
//		var finalTexture = context.RenderTarget2D_Alloc( actualTexture.Result.ResultSize, actualTexture.Result.ResultFormat );
//		{
//			context.SetViewport( finalTexture.Result.GetRenderTarget().Viewports[ 0 ] );

//			var debugMode = DebugMode.Value;

//			if( debugMode != DebugModeEnum.None )
//			{
//				var shader = new CanvasRenderer.ShaderItem();
//				shader.VertexProgramFileName = @"Base\Shaders\EffectsCommon_vs.sc";
//				shader.FragmentProgramFileName = @"Base\Shaders\Effects\ScreenSpaceReflection\SSR_Debug_fs.sc";

//				switch( debugMode )
//				{
//				case DebugModeEnum.ReflectionTexture:
//					shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, reflectionTexture, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );
//					break;

//				case DebugModeEnum.RoughnessMin:
//					shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, blurRoughnessMin, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );
//					break;

//				case DebugModeEnum.RoughnessMax:
//					shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, blurRoughnessMax, TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );
//					break;
//				}

//				context.RenderQuadToCurrentViewport( shader );
//			}
//			else
//			{


//				//!!!!
//				var ambientLight = frameData.Lights[ frameData.LightsInFrustumSorted[ 0 ] ];
//				var ambientLightPower = ambientLight.data.Power;

//				//!!!!reflection probes?
//				pipeline.GetBackgroundEnvironmentData( context, frameData, /*true, */out var environmentTexture, out var environmentTextureIBL );



//				var shader = new CanvasRenderer.ShaderItem();
//				shader.VertexProgramFileName = @"Base\Shaders\EffectsCommon_vs.sc";
//				shader.FragmentProgramFileName = @"Base\Shaders\Effects\ScreenSpaceReflection\SSR_Apply_fs.sc";

//				context.ObjectsDuringUpdate.namedTextures.TryGetValue( "gBuffer0Texture", out var gBuffer0Texture );
//				context.ObjectsDuringUpdate.namedTextures.TryGetValue( "depthTexture", out var depthTexture );
//				context.ObjectsDuringUpdate.namedTextures.TryGetValue( "normalTexture", out var normalTexture );
//				context.ObjectsDuringUpdate.namedTextures.TryGetValue( "gBuffer2Texture", out var gBuffer2Texture );

//				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 0, actualTexture,
//					TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//				//!!!!почему Point. что еще Linear сделать

//				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 1, blurRoughnessMin,
//					TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 2, blurRoughnessMax,
//					TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//				//shader.Parameters.Set( "1", new GpuMaterialPass.TextureParameterValue( reflectionTexture,
//				//	TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//				//shader.Parameters.Set( "2", new GpuMaterialPass.TextureParameterValue( bluredReflection,
//				//	TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 3, depthTexture,
//					TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 4, normalTexture,
//					TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.None ) );

//				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 5, environmentTexture.Texture,
//					TextureAddressingMode.Clamp, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );

//				//shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 6, environmentTextureIBL.Value.texture,
//				//	TextureAddressingMode.Clamp, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );

//				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 7, RenderingPipeline_Basic.BrdfLUT,
//					TextureAddressingMode.Clamp, FilterOption.Linear, FilterOption.Linear, FilterOption.Linear ) );

//				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 8, gBuffer2Texture,
//					TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.Point ) );

//				shader.Parameters.Set( new ViewportRenderingContext.BindTextureData( 9, gBuffer0Texture,
//					TextureAddressingMode.Clamp, FilterOption.Point, FilterOption.Point, FilterOption.Point ) );

//				//shader.Parameters.Set( "invViewProj", invViewProjMatrix );
//				shader.Parameters.Set( "intensity", (float)MathEx.Saturate( multiplier ) );// Intensity );

//				//!!!!prefixes

//				//!!!!почему юзается ambient light

//				shader.Parameters.Set( "ambientLightPower", ambientLightPower );
//				shader.Parameters.Set( "ambientLightTextureRotation", environmentTexture.Rotation.ToVector4() );
//				shader.Parameters.Set( "ambientLightTextureMultiplierAndAffect", environmentTexture.MultiplierAndAffect );

//				//var parameters = new Vector4F(  );
//				//shader.Parameters.Set( "u_reflectionParameters", parameters );

//				context.RenderQuadToCurrentViewport( shader );
//			}
//		}

//		//free targets
//		context.DynamicTexture_Free( reflectionTexture );
//		context.DynamicTexture_Free( blurRoughnessMin );
//		context.DynamicTexture_Free( blurRoughnessMax );
//		//context.RenderTarget_Free( bluredReflection );
//		context.DynamicTexture_Free( actualTexture );

//		//update result
//		sceneTexture = finalTexture;
//	}
//}

////private void Pipeline_RenderBegin( RenderingPipeline_Basic sender, ViewportRenderingContext context, RenderingPipeline_Basic.FrameData frameData )
////{
////	if( EnabledInHierarchy && sender.UseRenderTargets )
////	{
////		//frameData.GenerateIBLSpecularTexture = true;
////		//frameData.DeferredSpecularIBLItensity = 1.0 - Intensity;
////	}
////}
