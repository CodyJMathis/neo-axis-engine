// Copyright (C) NeoAxis Group Ltd. 8 Copthall, Roseau Valley, 00152 Commonwealth of Dominica.
using System;
using System.ComponentModel;
using System.Collections.Generic;
using NeoAxis.Editor;

namespace NeoAxis
{
	/// <summary>
	/// Mesh geometry in the form of polyhedron generated by thickening a polygon.
	/// </summary>
#if !DEPLOY
	[ObjectCreationMode( "NeoAxis.Editor.MeshGeometry_PolygonBasedPolyhedronCreationMode" )]
#endif
	public class MeshGeometry_PolygonBasedPolyhedron : MeshGeometry_Procedural
	{
		/// <summary>
		/// Whether the points are clockwise.
		/// </summary>
		[DefaultValue( false )]
		public Reference<bool> Clockwise
		{
			get { if( _clockwise.BeginGet() ) Clockwise = _clockwise.Get( this ); return _clockwise.value; }
			set { if( _clockwise.BeginSet( this, ref value ) ) { try { ClockwiseChanged?.Invoke( this ); ShouldRecompileMesh(); } finally { _clockwise.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="Clockwise"/> property value changes.</summary>
		public event Action<MeshGeometry_PolygonBasedPolyhedron> ClockwiseChanged;
		ReferenceField<bool> _clockwise = false;

		/// <summary>
		/// The height of the shape.
		/// </summary>
		[DefaultValue( 0.0 )]
		[Range( 0, 100, RangeAttribute.ConvenientDistributionEnum.Exponential, 4 )]
		public Reference<double> Height
		{
			get { if( _height.BeginGet() ) Height = _height.Get( this ); return _height.value; }
			set { if( _height.BeginSet( this, ref value ) ) { try { HeightChanged?.Invoke( this ); ShouldRecompileMesh(); } finally { _height.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="Height"/> property value changes.</summary>
		public event Action<MeshGeometry_PolygonBasedPolyhedron> HeightChanged;
		ReferenceField<double> _height = 0.0;

		/// <summary>
		/// Whether the box is flipped.
		/// </summary>
		[DefaultValue( false )]
		public Reference<bool> InsideOut
		{
			get { if( _insideOut.BeginGet() ) InsideOut = _insideOut.Get( this ); return _insideOut.value; }
			set { if( _insideOut.BeginSet( this, ref value ) ) { try { InsideOutChanged?.Invoke( this ); ShouldRecompileMesh(); } finally { _insideOut.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="InsideOut"/> property value changes.</summary>
		public event Action<MeshGeometry_PolygonBasedPolyhedron> InsideOutChanged;
		ReferenceField<bool> _insideOut = false;

		/// <summary>
		/// Whether to always display point labels or only when the object in the scene is selected.
		/// </summary>
		[DefaultValue( false )]
		public Reference<bool> AlwaysDisplayPointLabels
		{
			get { if( _alwaysDisplayPointLabels.BeginGet() ) AlwaysDisplayPointLabels = _alwaysDisplayPointLabels.Get( this ); return _alwaysDisplayPointLabels.value; }
			set { if( _alwaysDisplayPointLabels.BeginSet( this, ref value ) ) { try { AlwaysDisplayPointLabelsChanged?.Invoke( this ); } finally { _alwaysDisplayPointLabels.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="AlwaysDisplayPointLabels"/> property value changes.</summary>
		public event Action<MeshGeometry_PolygonBasedPolyhedron> AlwaysDisplayPointLabelsChanged;
		ReferenceField<bool> _alwaysDisplayPointLabels = false;

		/// <summary>
		/// The multiplier of output texture coordinates.
		/// </summary>
		[DefaultValue( "1 1" )]
		[DisplayName( "UV Scale" )]
		public Reference<Vector2> UVScale
		{
			get { if( _uVScale.BeginGet() ) UVScale = _uVScale.Get( this ); return _uVScale.value; }
			set { if( _uVScale.BeginSet( this, ref value ) ) { try { UVScaleChanged?.Invoke( this ); ShouldRecompileMesh(); } finally { _uVScale.EndSet(); } } }
		}
		/// <summary>Occurs when the <see cref="UVScale"/> property value changes.</summary>
		public event Action<MeshGeometry_PolygonBasedPolyhedron> UVScaleChanged;
		ReferenceField<Vector2> _uVScale = new Vector2( 1, 1 );

		/////////////////////////////////////////

		public MeshGeometry_PolygonBasedPolyhedron_Point[] GetPoints()
		{
			return GetComponents<MeshGeometry_PolygonBasedPolyhedron_Point>();
		}

		public Vector3[] GetPointPositions()
		{
			var points = GetPoints();
			var result = new Vector3[ points.Length ];
			for( int n = 0; n < points.Length; n++ )
				result[ n ] = points[ n ].TransformV.Position;
			return result;
		}

		public Plane GetPolygonPlaneByPoints()
		{
			var points = GetPointPositions();
			if( points.Length >= 3 )
				return Plane.FromPoints( points[ 0 ], points[ 1 ], points[ 2 ] );
			else
				return Plane.FromPointAndNormal( Vector3.Zero, Vector3.ZAxis );
		}

		public override void GetProceduralGeneratedData( ref VertexElement[] vertexStructure, ref byte[] vertices, ref int[] indices, ref Material material, ref byte[] voxelData, ref byte[] clusterData, ref Mesh.StructureClass structure )
		{
			var meshInSpace = Parent?.Parent as MeshInSpace;
			var points = GetPointPositions();

			if( meshInSpace != null && points.Length >= 3 )
			{
				vertexStructure = StandardVertex.MakeStructure( StandardVertex.Components.StaticOneTexCoord, true, out int vertexSize );
				unsafe
				{
					if( vertexSize != sizeof( StandardVertex.StaticOneTexCoord ) )
						Log.Fatal( "vertexSize != sizeof( StandardVertexF )" );
				}

				SimpleMeshGenerator.GeneratePolygonBasedPolyhedron( points, Clockwise, Height, InsideOut, null, out Vector3[] positions, out Vector3[] normals, out Vector4[] tangents, out Vector2[] texCoords, out indices, out var faces );

				var uvScale = UVScale.Value;
				if( uvScale != Vector2.One )
				{
					for( int n = 0; n < texCoords.Length; n++ )
						texCoords[ n ] *= uvScale;
				}

				if( faces != null )
					structure = SimpleMeshGenerator.CreateMeshStructure( faces );

				var transformInverted = meshInSpace.TransformV.ToMatrix4().GetInverse();
				var rotationInverted = meshInSpace.TransformV.Rotation.GetInverse().ToMatrix3();

				vertices = new byte[ vertexSize * positions.Length ];
				unsafe
				{
					fixed( byte* pVertices = vertices )
					{
						StandardVertex.StaticOneTexCoord* pVertex = (StandardVertex.StaticOneTexCoord*)pVertices;

						for( int n = 0; n < positions.Length; n++ )
						{
							pVertex->Position = ( transformInverted * positions[ n ] ).ToVector3F();
							pVertex->Normal = ( rotationInverted * normals[ n ] ).ToVector3F().GetNormalize();
							pVertex->Tangent = tangents[ n ].ToVector4F();
							pVertex->Color = new ColorValue( 1, 1, 1, 1 );
							pVertex->TexCoord0 = texCoords[ n ].ToVector2F();

							pVertex++;
						}
					}
				}
			}
		}

		protected override void OnComponentAdded( Component component )
		{
			base.OnComponentAdded( component );

			if( component is MeshGeometry_PolygonBasedPolyhedron_Point )
				ShouldRecompileMesh();
		}

		protected override void OnComponentRemoved( Component component )
		{
			base.OnComponentRemoved( component );

			if( component is MeshGeometry_PolygonBasedPolyhedron_Point )
				ShouldRecompileMesh();
		}

		protected override void OnEnabledInHierarchyChanged()
		{
			base.OnEnabledInHierarchyChanged();

			var meshInSpace = Parent?.Parent as MeshInSpace;
			if( meshInSpace != null )
			{
				if( EnabledInHierarchy )
					meshInSpace.TransformChanged += MeshInSpace_TransformChanged;
				else
					meshInSpace.TransformChanged -= MeshInSpace_TransformChanged;
			}
		}

		private void MeshInSpace_TransformChanged( ObjectInSpace obj )
		{
			ShouldRecompileMesh();
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	/// <summary>
	/// Represents a point of the <see cref="MeshGeometry_PolygonBasedPolyhedron"/>.
	/// </summary>
	public class MeshGeometry_PolygonBasedPolyhedron_Point : ObjectInSpace
	{
		//!!!!good?
		bool lastDisableShowingLabelForThisObject;

		//

		protected override void OnGetRenderSceneData( ViewportRenderingContext context, GetRenderSceneDataMode mode, Scene.GetObjectsInSpaceItem modeGetObjectsItem )
		{
			lastDisableShowingLabelForThisObject = false;

			//hide label
			var geometry = Parent as MeshGeometry_PolygonBasedPolyhedron;
			if( geometry != null )
			{
				//context.objectInSpaceRenderingContext.objectToCreate

				if( !geometry.AlwaysDisplayPointLabels )
				{
					var context2 = context.ObjectInSpaceRenderingContext;

					var objectsToCheck = new List<object>();
					{
						objectsToCheck.Add( geometry );
						objectsToCheck.AddRange( geometry.GetPoints() );

						var mesh = geometry.Parent;
						if( mesh != null )
						{
							objectsToCheck.Add( mesh );

							var meshInSpace = mesh.Parent;
							if( meshInSpace != null )
								objectsToCheck.Add( meshInSpace );
						}
					}

					bool display = false;
					foreach( var obj in objectsToCheck )
					{
						display = context2.selectedObjects.Contains( obj ) || context2.objectToCreate == obj;
						if( display )
							break;
					}

					if( !display )
					{
						context2.disableShowingLabelForThisObject = true;
						lastDisableShowingLabelForThisObject = true;
					}
				}
			}
		}

		protected override bool OnEnabledSelectionByCursor()
		{
			if( !ParentScene.GetDisplayDevelopmentDataInThisApplication() || !ParentScene.DisplayLabels )
				return false;
			if( lastDisableShowingLabelForThisObject )
				return false;
			return base.OnEnabledSelectionByCursor();
		}

		protected override void OnTransformChanged()
		{
			base.OnTransformChanged();

			var geometry = Parent as MeshGeometry_PolygonBasedPolyhedron;
			geometry?.ShouldRecompileMesh();
		}
	}
}
