/*-------------------------------------------------------------------------
This source file is a part of OGRE
(Object-oriented Graphics Rendering Engine)

For the latest info, see http://www.ogre3d.org/

Copyright (c) 2000-2009 Torus Knot Software Ltd
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE
-------------------------------------------------------------------------*/
#ifndef __OgrePrerequisites_H__
#define __OgrePrerequisites_H__

// Platform-specific stuff
#include "OgrePlatform.h"

#if OGRE_COMPILER == OGRE_COMPILER_MSVC
// Turn off warnings generated by long std templates
// This warns about truncation to 255 characters in debug/browse info
#   pragma warning (disable : 4786)

// Turn off warnings generated by long std templates
// This warns about truncation to 255 characters in debug/browse info
#   pragma warning (disable : 4503)

// disable: "conversion from 'double' to 'float', possible loss of data
#   pragma warning (disable : 4244)

// disable: "truncation from 'double' to 'float'
#   pragma warning (disable : 4305)

// disable: "<type> needs to have dll-interface to be used by clients'
// Happens on STL member variables which are not public therefore is ok
#   pragma warning (disable : 4251)

// disable: "non dll-interface class used as base for dll-interface class"
// Happens when deriving from Singleton because bug in compiler ignores
// template export
#   pragma warning (disable : 4275)

// disable: "C++ Exception Specification ignored"
// This is because MSVC 6 did not implement all the C++ exception
// specifications in the ANSI C++ draft.
#   pragma warning( disable : 4290 )

// disable: "no suitable definition provided for explicit template
// instantiation request" Occurs in VC7 for no justifiable reason on all
// #includes of Singleton
#   pragma warning( disable: 4661)

// disable: deprecation warnings when using CRT calls in VC8
// These show up on all C runtime lib code in VC8, disable since they clutter
// the warnings with things we may not be able to do anything about (e.g.
// generated code from nvparse etc). I doubt very much that these calls
// will ever be actually removed from VC anyway, it would break too much code.
#	pragma warning( disable: 4996)

// disable: "conditional expression constant", always occurs on 
// OGRE_MUTEX_CONDITIONAL when no threading enabled
#   pragma warning (disable : 201)

#endif


//betauser

//#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32 || OGRE_PLATFORM == OGRE_PLATFORM_WINRT
//	#define _MFC_OVERRIDES_NEW
//	#include <crtdbg.h>
//
//	#define _HAS_ITERATOR_DEBUGGING 0
//
//#endif

#include <memory.h>
#include <stdlib.h>
#if OGRE_PLATFORM != OGRE_PLATFORM_APPLE
	#include <malloc.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <wchar.h>
#ifdef ANDROID
	#include <cctype>
	#include <cstddef>
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE
	#include <new>
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32// || OGRE_PLATFORM == OGRE_PLATFORM_WINRT
#define USE_NATIVE_MEMORY_MANAGER
#endif

#ifdef USE_NATIVE_MEMORY_MANAGER
#define _DefinedMemoryAllocationType MemoryAllocationType_Renderer
#include "MemoryManager.h"
#include "MemoryManager_SimpleNew.h"

#endif //USE_NATIVE_MEMORY_MANAGER

#include "OgreStdHeaders.h"
#include "OgreAlignedAllocator.h"

#ifdef USE_NATIVE_MEMORY_MANAGER
#include "MemoryManager_ManageNew.h"
#endif

//betauser END


// configure memory tracking
#if OGRE_DEBUG_MODE 
#	if OGRE_MEMORY_TRACKER_DEBUG_MODE
#		define OGRE_MEMORY_TRACKER 1
#	else
#		define OGRE_MEMORY_TRACKER 0
#	endif
#else
#	if OGRE_MEMORY_TRACKER_RELEASE_MODE
#		define OGRE_MEMORY_TRACKER 1
#	else
#		define OGRE_MEMORY_TRACKER 0
#	endif
#endif




namespace Ogre {
    // Define ogre version
    #define OGRE_VERSION_MAJOR 1
    #define OGRE_VERSION_MINOR 10
    #define OGRE_VERSION_PATCH 333
	#define OGRE_VERSION_SUFFIX ""
    #define OGRE_VERSION_NAME "Xalafu"

    #define OGRE_VERSION    ((OGRE_VERSION_MAJOR << 16) | (OGRE_VERSION_MINOR << 8) | OGRE_VERSION_PATCH)

    // define the real number values to be used
    // default to use 'float' unless precompiler option set
    #if OGRE_DOUBLE_PRECISION == 1
		/** Software floating point type.
		@note Not valid as a pointer to GPU buffers / parameters
		*/
        typedef double Real;
    #else
		/** Software floating point type.
		@note Not valid as a pointer to GPU buffers / parameters
		*/
        typedef float Real;
    #endif

//!!!!new UWP
	#define HashMap ::std::unordered_map
	#define HashMultiMap ::std::unordered_multimap
	#define HashSet ::std::unordered_set
	#define HashMultiSet ::std::unordered_multiset

//!!!!old
/*
    #if OGRE_COMPILER == OGRE_COMPILER_GNUC && OGRE_COMP_VER >= 310 && !defined(STLPORT)
	#   if OGRE_COMP_VER >= 430
	#       define HashMap ::std::tr1::unordered_map
	#	    define HashMultiMap::std::tr1::unordered_multimap
	#		define HashSet ::std::tr1::unordered_set
	#		define HashMultiSet::std::tr1::unordered_multiset
	#    else
    #   define HashMap ::__gnu_cxx::hash_map
	#       define HashSet ::__gnu_cxx::hash_set
	#    endif
	#elif OGRE_COMPILER == OGRE_COMPILER_CLANG
	#    if defined(_LIBCPP_VERSION)
	#       define HashMap ::std::unordered_map
	#       define HashMultiMap ::std::unordered_multimap
	#       define HashSet ::std::unordered_set
	#       define HashMultiSet ::std::unordered_multiset
	#    else
	#       define HashMap ::std::tr1::unordered_map
	#       define HashMultiMap ::std::tr1::unordered_multimap
	#       define HashSet ::std::tr1::unordered_set
	#       define HashMultiSet ::std::tr1::unordered_multiset
	#    endif
    #else
    #   if OGRE_COMPILER == OGRE_COMPILER_MSVC
    #       if OGRE_COMP_VER >= 1600 // VC++ 10.0
	#			define HashMap ::std::tr1::unordered_map
	#           define HashSet ::std::tr1::unordered_set
	#		elif OGRE_COMP_VER > 1300 && !defined(_STLP_MSVC)
    #           define HashMap ::stdext::hash_map
	#           define HashSet ::stdext::hash_set
    #       else
    #           define HashMap ::std::hash_map
	#           define HashSet ::std::hash_set
    #       endif
    #   else
    #       define HashMap ::std::hash_map
	#       define HashSet ::std::hash_set
    #   endif
    #endif
*/

    /** In order to avoid finger-aches :)
    */
    typedef unsigned char uchar;
	typedef unsigned short ushort;
    typedef unsigned int uint;
	typedef unsigned long ulong;


	// Useful threading defines
#include "OgreThreadDefines.h"


#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32 || OGRE_PLATFORM == OGRE_PLATFORM_WINRT
	typedef wchar_t wchar16;
#else
	typedef unsigned short wchar16;
#endif

	typedef std::string _StringBase;
	typedef _StringBase String;
	typedef std::wstring _WStringBase;
	typedef _WStringBase WString;



// Pre-declare classes
// Allows use of pointers in header files without including individual .h
// so decreases dependencies between files
    class Angle;
    class Archive;
    class ArchiveFactory;
    class ArchiveManager;
    //class AutoParamDataSource;
    class AxisAlignedBox;
	class AxisAlignedBoxD;
	class Bone;
    //class Camera;
    class Codec;
    class ColourValue;
 //   template <typename T> class Controller;
 //   template <typename T> class ControllerFunction;
 //   class ControllerManager;
 //   template <typename T> class ControllerValue;
	//class DefaultWorkQueue;
    class Degree;
    class DynLib;
    class DynLibManager;
    //class EdgeData;
    class Factory;
    struct FrameEvent;
    //class FrameListener;
    //class Frustum;
    //class IndexData;
    class Image;
    //class KeyFrame;
    //class Light;
    class Log;
    class LogManager;
	class ManualResourceLoader;
    //class Material;
    //class MaterialPtr;
    //class MaterialManager;
    class Math;
    class Matrix3;
    class Matrix4;
    class MemoryManager;
 //   class Mesh;
 //   class MeshPtr;
 //   class MeshSerializer;
 //   class MeshSerializerImpl;
 //   class MeshManager;
    //class MovableObject;
 //   class Node;
	//class NodeAnimationTrack;
	//class NodeKeyFrame;
	//class NumericAnimationTrack;
	//class NumericKeyFrame;
    class PixelBox;
    class Plane;
    class PlaneBoundedVolume;
    //class Pose;
    class Profile;
    class Quaternion;
	class Radian;
	class RadianD;
	class DegreeD;
	class AxisAlignedBoxD;
	class PlaneD;
	class RayD;
	class Ray;
    //class Renderable;
    class RenderSystem;
    //class RenderOperation;
    class Resource;
	//class ResourceBackgroundQueue;
	class ResourceGroupManager;
    class ResourceManager;
	class Root;
    class SceneManager;
    class SceneManagerEnumerator;
	//class ScriptLoader;
    //class Serializer;
    //class SimpleSpline;
    //class Skeleton;
    //class SkeletonPtr;
    //class SkeletonInstance;
    //class SkeletonManager;
    class Sphere;
	class SphereD;
	class Vector3D;
	class Matrix3D;
	class StringConverter;
    //class StringInterface;
    //class SubMesh;
    //class Technique;
    //class TextureUnitState;
    class UserDefinedObject;
    class Vector2;
    class Vector3;
    class Vector4;
	//class VertexAnimationTrack;
//    class VertexBufferBinding;
//    class VertexData;
   class VertexDeclaration;

	//class VertexMorphKeyFrame;
	class DDSCodec;
	class PVRTCCodec;
	class ImageCodec;

//!!!dx11 new
	template<typename T> class SharedPtr;
}

class MyOgreVirtualArchiveFactory;
//class StaticMeshObjectRenderable;
class DebugGeometryRenderable;
class GuiRendererItemRenderable;

/* Include all the standard header *after* all the configuration
settings have been made.
*/
#include "OgreStdHeaders.h"
#include "OgreMemoryAllocatorConfig.h"


namespace Ogre
{
#if OGRE_STRING_USE_CUSTOM_MEMORY_ALLOCATOR
	#if OGRE_WCHAR_T_STRINGS
		typedef std::basic_string<wchar_t, std::char_traits<wchar_t>, STLAllocator<wchar_t,GeneralAllocPolicy > >	_StringBase;
	#else
		typedef std::basic_string<char, std::char_traits<char>, STLAllocator<char,GeneralAllocPolicy > >	_StringBase;
	#endif

	#if OGRE_WCHAR_T_STRINGS
		typedef std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,STLAllocator<wchar_t,GeneralAllocPolicy >> _StringStreamBase;
	#else
		typedef std::basic_stringstream<char,std::char_traits<char>,STLAllocator<char,GeneralAllocPolicy > > _StringStreamBase;
	#endif

	#define StdStringT(T) std::basic_string<T, std::char_traits<T>, std::allocator<T> >	
	#define CustomMemoryStringT(T) std::basic_string<T, std::char_traits<T>, STLAllocator<T,GeneralAllocPolicy> >	

	template<typename T>
	bool operator <(const CustomMemoryStringT(T)& l,const StdStringT(T)& o)
	{
		return l.compare(0,l.length(),o.c_str(),o.length())<0;
	}
	template<typename T>
	bool operator <(const StdStringT(T)& l,const CustomMemoryStringT(T)& o)
	{
		return l.compare(0,l.length(),o.c_str(),o.length())<0;
	}
	template<typename T>
	bool operator <=(const CustomMemoryStringT(T)& l,const StdStringT(T)& o)
	{
		return l.compare(0,l.length(),o.c_str(),o.length())<=0;
	}
	template<typename T>
	bool operator <=(const StdStringT(T)& l,const CustomMemoryStringT(T)& o)
	{
		return l.compare(0,l.length(),o.c_str(),o.length())<=0;
	}
	template<typename T>
	bool operator >(const CustomMemoryStringT(T)& l,const StdStringT(T)& o)
	{
		return l.compare(0,l.length(),o.c_str(),o.length())>0;
	}
	template<typename T>
	bool operator >(const StdStringT(T)& l,const CustomMemoryStringT(T)& o)
	{
		return l.compare(0,l.length(),o.c_str(),o.length())>0;
	}
	template<typename T>
	bool operator >=(const CustomMemoryStringT(T)& l,const StdStringT(T)& o)
	{
		return l.compare(0,l.length(),o.c_str(),o.length())>=0;
	}
	template<typename T>
	bool operator >=(const StdStringT(T)& l,const CustomMemoryStringT(T)& o)
	{
		return l.compare(0,l.length(),o.c_str(),o.length())>=0;
	}

	template<typename T>
	bool operator ==(const CustomMemoryStringT(T)& l,const StdStringT(T)& o)
	{
		return l.compare(0,l.length(),o.c_str(),o.length())==0;
	}
	template<typename T>
	bool operator ==(const StdStringT(T)& l,const CustomMemoryStringT(T)& o)
	{
		return l.compare(0,l.length(),o.c_str(),o.length())==0;
	}

	template<typename T>
	bool operator !=(const CustomMemoryStringT(T)& l,const StdStringT(T)& o)
	{
		return l.compare(0,l.length(),o.c_str(),o.length())!=0;
	}
	template<typename T>
	bool operator !=(const StdStringT(T)& l,const CustomMemoryStringT(T)& o)
	{
		return l.compare(0,l.length(),o.c_str(),o.length())!=0;
	}

	template<typename T>
	CustomMemoryStringT(T) operator +=(const CustomMemoryStringT(T)& l,const StdStringT(T)& o)
	{
		return CustomMemoryStringT(T)(l)+=o.c_str();
	}
	template<typename T>
	CustomMemoryStringT(T) operator +=(const StdStringT(T)& l,const CustomMemoryStringT(T)& o)
	{
		return CustomMemoryStringT(T)(l.c_str())+=o.c_str();
	}

	template<typename T>
	CustomMemoryStringT(T) operator +(const CustomMemoryStringT(T)& l,const StdStringT(T)& o)
	{
		return CustomMemoryStringT(T)(l)+=o.c_str();
	}

	template<typename T>
	CustomMemoryStringT(T) operator +(const StdStringT(T)& l,const CustomMemoryStringT(T)& o)
	{
		return CustomMemoryStringT(T)(l.c_str())+=o.c_str();
	}

	template<typename T>
	CustomMemoryStringT(T) operator +(const T* l,const CustomMemoryStringT(T)& o)
	{
		return CustomMemoryStringT(T)(l)+=o;
	}

	#undef StdStringT
	#undef CustomMemoryStringT

#else
	#if OGRE_WCHAR_T_STRINGS
		typedef std::wstring _StringBase;
	#else
		typedef std::string _StringBase;
	#endif

	#if OGRE_WCHAR_T_STRINGS
		typedef std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > _StringStreamBase;
	#else
		typedef std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > _StringStreamBase;
	#endif

#endif

	typedef _StringBase String;
	typedef _StringStreamBase StringStream;
	typedef StringStream stringstream;

	// !!!! OLD WAY definition.
	// !!!! maybe fix it and use only one String type without conversiobns ?
	typedef std::basic_stringstream<char, std::char_traits<char>, std::allocator<char> > StringStream;
	typedef std::basic_stringstream<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > WStringStream;
	//
}

////for stl containter
//namespace Ogre
//{ 
//	template <typename T, typename A = STLAllocator<T, GeneralAllocPolicy> > 
//	struct deque 
//	{ 
//#if OGRE_CONTAINERS_USE_CUSTOM_MEMORY_ALLOCATOR
//	   typedef typename std::deque<T, A> type;    
//#else
//		typedef typename std::deque<T> type;    
//#endif
//	}; 
//
//	template <typename T, typename A = STLAllocator<T, GeneralAllocPolicy> > 
//	struct vector 
//	{ 
//#if OGRE_CONTAINERS_USE_CUSTOM_MEMORY_ALLOCATOR
//		typedef typename std::vector<T, A> type;    
//#else
//		typedef typename std::vector<T> type;    
//#endif
//	}; 
//
//	template <typename T, typename A = STLAllocator<T, GeneralAllocPolicy> > 
//	struct list 
//	{ 
//#if OGRE_CONTAINERS_USE_CUSTOM_MEMORY_ALLOCATOR
//	   typedef typename std::list<T, A> type;    
//#else
//		typedef typename std::list<T> type;    
//#endif
//	}; 
//
//	template <typename T, typename P = std::less<T>, typename A = STLAllocator<T, GeneralAllocPolicy> > 
//	struct set 
//	{ 
//#if OGRE_CONTAINERS_USE_CUSTOM_MEMORY_ALLOCATOR
//	   typedef typename std::set<T, P, A> type;    
//#else
//		typedef typename std::set<T, P> type;    
//#endif
//	}; 
//
//	template <typename K, typename V, typename P = std::less<K>, typename A = STLAllocator<std::pair<const K, V>, GeneralAllocPolicy> > 
//	struct map 
//	{ 
//#if OGRE_CONTAINERS_USE_CUSTOM_MEMORY_ALLOCATOR
//	   typedef typename std::map<K, V, P, A> type; 
//#else
//		typedef typename std::map<K, V, P> type; 
//#endif
//	}; 
//
//	template <typename K, typename V, typename P = std::less<K>, typename A = STLAllocator<std::pair<const K, V>, GeneralAllocPolicy> > 
//	struct multimap 
//	{ 
//#if OGRE_CONTAINERS_USE_CUSTOM_MEMORY_ALLOCATOR
//		typedef typename std::multimap<K, V, P, A> type; 
//#else
//		typedef typename std::multimap<K, V, P> type; 
//#endif
//	}; 
//
//} // Ogre

extern void Fatal(const char* text);
extern void Fatal(const Ogre::String& text);
extern void Fatal(const Ogre::WString& text);

extern void DebugMessage(const char* text);
extern void DebugMessage(const Ogre::String& text);
extern void DebugMessage(const Ogre::WString& text);


//----------------------------------------------------------------------------
// define TO_WCHAR16, TO_WCHAR_T

#ifdef _WIN32

	#define TO_WCHAR16(_str) _str
	#define TO_WCHAR_T(_str) _str

#else

	class UTF32ToUTF16Converter
	{
		Ogre::wchar16* buffer;

	public:
		UTF32ToUTF16Converter(const wchar_t* str)
		{
			int len = wcslen(str);
			buffer = new Ogre::wchar16[len + 1];
			for(int n = 0; n < len; n++)
				buffer[n] = (Ogre::wchar16)str[n];
			buffer[len] = 0;
		}

		~UTF32ToUTF16Converter()
		{
			delete[] buffer;
		}

		operator const Ogre::wchar16*()
		{
			return buffer;
		}
	};

	class UTF16ToUTF32Converter
	{
		Ogre::WString buffer;

	public:
		UTF16ToUTF32Converter(const Ogre::wchar16* str)
		{
			int len = 0;
			for(int n = 0; ; n++)
			{
				if(str[n] == 0)
					break;
				len++;
			}
			buffer.resize(len);
			for(int n = 0; n < len; n++)
				buffer[n] = (wchar_t)str[n];
			buffer[len] = 0;
		}

		operator const Ogre::WString&()
		{
			return buffer;
		}
	};

	#define TO_WCHAR16(_str) UTF32ToUTF16Converter( (_str) )
	#define TO_WCHAR_T(_str) UTF16ToUTF32Converter( (_str) )

#endif

//----------------------------------------------------------------------------


#endif // __OgrePrerequisites_H__


